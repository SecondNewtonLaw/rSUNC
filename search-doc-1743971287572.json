{"searchDocs":[{"title":"rSUNC and UNC","type":0,"sectionRef":"#","url":"/rSUNC/docs/UNCRetroCompatibility","content":"rSUNC and UNC rSUNC remains partly compatible with the now old UNC, it is partly compatible due to the fact some functions, such as the entirety of the cache library, has been replaced by the instances library, with the functions it once contained renamed to be far more descriptive. The documentation also attempts to be as descriptive as possible as to what the function should do, the arguments it should take, and the errors that they should throw on unique cases. This allows script developers to use pcall and obtain the error if applicable, and attempt to handle them in some way by themselves. This also allows executor developers to know how a function should behave and what it should do. This allows developers to gracefully handle errors, as well as display better detail errors. Instead of a simple Unsupported you can have a fancier Function 'getfunctionhash' does not support the hashing required. This can help you debug the scripts in a more efficient manner. Most of rSUNC remains compatible with UNC. However as more developments come, the standards drift further and further apart.","keywords":"","version":"Next"},{"title":"rSUNCHttpRequest","type":0,"sectionRef":"#","url":"/rSUNC/api/rSUNCHttpRequest","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"rSUNCHttpRequest","url":"/rSUNC/api/rSUNCHttpRequest#properties","content":" ","version":null,"tagName":"h2"},{"title":"Url​","type":1,"pageTitle":"rSUNCHttpRequest","url":"/rSUNC/api/rSUNCHttpRequest#Url","content":"&lt;/&gt; rSUNCHttpRequest.Url: string The URL to send the request to  ","version":null,"tagName":"h3"},{"title":"Method​","type":1,"pageTitle":"rSUNCHttpRequest","url":"/rSUNC/api/rSUNCHttpRequest#Method","content":"&lt;/&gt; rSUNCHttpRequest.Method: &quot;GET&quot; | &quot;POST&quot; | &quot;PATCH&quot; | &quot;PUT&quot; | &quot;DELETE&quot; The HTTP method this request needs to be done with  ","version":null,"tagName":"h3"},{"title":"Body​","type":1,"pageTitle":"rSUNCHttpRequest","url":"/rSUNC/api/rSUNCHttpRequest#Body","content":"&lt;/&gt; rSUNCHttpRequest.Body: string? The body of the HTTP request. May be empty.  ","version":null,"tagName":"h3"},{"title":"Headers​","type":1,"pageTitle":"rSUNCHttpRequest","url":"/rSUNC/api/rSUNCHttpRequest#Headers","content":"&lt;/&gt; rSUNCHttpRequest.Headers: {[string]: string} Table of HTTP headers.  ","version":null,"tagName":"h3"},{"title":"Cookies​","type":1,"pageTitle":"rSUNCHttpRequest","url":"/rSUNC/api/rSUNCHttpRequest#Cookies","content":"&lt;/&gt; rSUNCHttpRequest.Cookies: {[string]: string} Table of Cookies. ","version":null,"tagName":"h3"},{"title":"rSUNCHttpResponse","type":0,"sectionRef":"#","url":"/rSUNC/api/rSUNCHttpResponse","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"rSUNCHttpResponse","url":"/rSUNC/api/rSUNCHttpResponse#properties","content":" ","version":null,"tagName":"h2"},{"title":"Body​","type":1,"pageTitle":"rSUNCHttpResponse","url":"/rSUNC/api/rSUNCHttpResponse#Body","content":"&lt;/&gt; rSUNCHttpResponse.Body: string The response of the HTTP Server.  ","version":null,"tagName":"h3"},{"title":"StatusMessage​","type":1,"pageTitle":"rSUNCHttpResponse","url":"/rSUNC/api/rSUNCHttpResponse#StatusMessage","content":"&lt;/&gt; rSUNCHttpResponse.StatusMessage: string A string representation of the StatusCode property.  ","version":null,"tagName":"h3"},{"title":"StatusCode​","type":1,"pageTitle":"rSUNCHttpResponse","url":"/rSUNC/api/rSUNCHttpResponse#StatusCode","content":"&lt;/&gt; rSUNCHttpResponse.StatusCode: number The Http Status Code of the request.  ","version":null,"tagName":"h3"},{"title":"Headers​","type":1,"pageTitle":"rSUNCHttpResponse","url":"/rSUNC/api/rSUNCHttpResponse#Headers","content":"&lt;/&gt; rSUNCHttpResponse.Headers: {[string]: string} Table of HTTP headers.  ","version":null,"tagName":"h3"},{"title":"Success​","type":1,"pageTitle":"rSUNCHttpResponse","url":"/rSUNC/api/rSUNCHttpResponse#Success","content":"&lt;/&gt; rSUNCHttpResponse.Success: boolean Whether the request was successful. ","version":null,"tagName":"h3"},{"title":"Why should you use rSUNC?","type":0,"sectionRef":"#","url":"/rSUNC/docs/WhyrSUNC","content":"Why should you use rSUNC? rSUNC has been built from the ground up with new libraries and functions, providing a new way of using executors. These functions hand off more control to script developers as well as providing functions for the changes brought forward by the change of Luau, such as Native Code Generation! These libraries ensure that rSUNC can stay up-to-date with the latest changes, as well as providing a new working base for executors, who would otherwise be implementing UNC, a standard that has began to show its age more and more with the passing of time, and has been deprecated for quite some time now.","keywords":"","version":"Next"},{"title":"memory","type":0,"sectionRef":"#","url":"/rSUNC/api/memory","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"memory","url":"/rSUNC/api/memory#functions","content":" ","version":null,"tagName":"h2"},{"title":"getgc​","type":1,"pageTitle":"memory","url":"/rSUNC/api/memory#getgc","content":"&lt;/&gt; memory.getgc( includeTables: boolean?-- Whether to include tables in the list. Defaults to false if not provided. ) → {vector | buffer | {[any]: any} | string | (...any) → ...any} | {vector | buffer | string | (...any) → ...any}-- A list of objects currently 'alive' in the garbage collector. Returns a list of objects currently 'alive' in the garbage collector. Implementation This function must automatically suspend the GC to retrieve the list of objects that are correct for when the call originates.  ","version":null,"tagName":"h3"},{"title":"suspendgc​","type":1,"pageTitle":"memory","url":"/rSUNC/api/memory#suspendgc","content":"&lt;/&gt; memory.suspendgc() → GcState-- The current state of the Garbage Collector, before suspension. Suspends all GC operations temporarily, returning the current state of the Garbage Collector to resume it. Memory Usage After this function is called, memory usage may increase, as after this call the garbage collector is simply no longer collecting memory. You may forcefully request the GC to run using memory.gc or memory.stepgc. Granting you full control over the GC. Resumption after Suspension After the Garbage Collector is suspended, a call to memory.resumegc must follow eventually. If the thread does not resume the GC and it stops execution (i.e.: thread yields or dies), it will automatically resume itself on the next scheduler cycle in order to prevent a memory leak. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"memory","url":"/rSUNC/api/memory##","content":"Type\tDescriptionAlready suspended\tThe Garbage collector is already suspended. You must first resume it using memory.resumegc before calling memory.suspendgc again.  ","version":null,"tagName":"h3"},{"title":"resumegc​","type":1,"pageTitle":"memory","url":"/rSUNC/api/memory#resumegc","content":"&lt;/&gt; memory.resumegc() → () Resumes the Garbage Collector from the previous state ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"memory","url":"/rSUNC/api/memory##","content":"Type\tDescriptionGarbage Collector Not Suspended\tThe garbage collector is not suspended, you cannot resume it!  ","version":null,"tagName":"h3"},{"title":"getgcstate​","type":1,"pageTitle":"memory","url":"/rSUNC/api/memory#getgcstate","content":"&lt;/&gt; memory.getgcstate() → GcState-- The current state of the Garbage Collector Retrieves a copy of the current state of the garbage collector.  ","version":null,"tagName":"h3"},{"title":"gc​","type":1,"pageTitle":"memory","url":"/rSUNC/api/memory#gc","content":"&lt;/&gt; memory.gc() → () Executes a full garbage collection cycle, regardless if it should be ran or not. This will temporarily stop the world to execute a full GC step. WARNING This may have a performance cost depending on how big the heap is, and could temporarily pause Roblox!  ","version":null,"tagName":"h3"},{"title":"stepgc​","type":1,"pageTitle":"memory","url":"/rSUNC/api/memory#stepgc","content":"&lt;/&gt; memory.stepgc() → () Executes a step on the garbage collection cycle, regardless if it should be ran or not.  ","version":null,"tagName":"h3"},{"title":"isreferenced​","type":1,"pageTitle":"memory","url":"/rSUNC/api/memory#isreferenced","content":"&lt;/&gt; memory.isreferenced( object: any-- The object to check. ) → boolean Checks if the given object is currently referenced in the Lua(u) registry. Remarks This function checks both registry keys and values in search of the given object. This means that if getreg()[object] holds a value, this function must return true. Examples local part = Instance.new(&quot;Part&quot;) getreg()[part] = true assert(memory.isreferenced(part) == true, &quot;memory.isreferenced must return true once the object is present in the registry, be it in a key, or in a value!&quot;) getreg()[part] = nil assert(memory.isreferenced(part) == false, &quot;memory.isreferenced must return false once the object is no longer present in the registry!&quot;)  ","version":null,"tagName":"h3"},{"title":"rsunc","type":0,"sectionRef":"#","url":"/rSUNC/api/rsunc","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"rsunc","url":"/rSUNC/api/rsunc#functions","content":" ","version":null,"tagName":"h2"},{"title":"getgenv​","type":1,"pageTitle":"rsunc","url":"/rSUNC/api/rsunc#getgenv","content":"&lt;/&gt; rsunc.getgenv() → {[any]: any}-- The global environment of the executor. Obtains the global environment of the executor. Contains all of rSUNC globals. Sandboxing All threads must be sandboxed. This means that modifications to the current thread's global environment should NOT pollute the result of getgenv. Modifications done to the table returned by getgenv must be observable to all threads an executor makes, but not observable to other threads within the VM, such as game threads. Example: do -- Thread 1 HelloVariable = &quot;Hello&quot; print(HelloVariable) -- prints 'Hello' print(HelloVariableViaGetGenv) -- prints 'nil' print(getgenv().HelloVariableViaGetGenv) -- prints 'nil' getgenv().HelloVariableViaGetGenv = HelloVariable -- Set HelloVariableViaGetGenv to the value of HelloVariable (can be observed by Thread 2!) print(HelloVariable) -- prints 'Hello' print(HelloVariableViaGetGenv) -- prints 'Hello' print(getgenv().HelloVariableViaGetGenv) -- prints 'Hello' end -- ... do -- Thread 2 (runs after thread 1) print(HelloVariable) -- prints 'nil' print(HelloVariableViaGetGenv) -- prints 'Hello' print(getgenv().HelloVariableViaGetGenv) -- prints 'Hello' end   ","version":null,"tagName":"h3"},{"title":"getrenv​","type":1,"pageTitle":"rsunc","url":"/rSUNC/api/rsunc#getrenv","content":"&lt;/&gt; rsunc.getrenv() → {[any]: any} Returns the global environment of main thread of Luau. This environment is different from the executor environment. Sandboxing You must NOT modify this environment under ANY circumstance. ANY modification will be observable by all threads in the VM.  ","version":null,"tagName":"h3"},{"title":"getreg​","type":1,"pageTitle":"rsunc","url":"/rSUNC/api/rsunc#getreg","content":"&lt;/&gt; rsunc.getreg() → {[any]: any}-- The Luau registry Returns the Luau registry.  ","version":null,"tagName":"h3"},{"title":"getscriptglobals​","type":1,"pageTitle":"rsunc","url":"/rSUNC/api/rsunc#getscriptglobals","content":"&lt;/&gt; rsunc.getscriptglobals() → { _G: {[any]: any}, shared: {[any]: any} } Returns the _G and shared script globals. ","version":null,"tagName":"h3"},{"title":"GcState","type":0,"sectionRef":"#","url":"/rSUNC/api/GcState","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"GcState","url":"/rSUNC/api/GcState#properties","content":" ","version":null,"tagName":"h2"},{"title":"GCThreshold​","type":1,"pageTitle":"GcState","url":"/rSUNC/api/GcState#GCThreshold","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; GcState.GCThreshold: userdata&lt;std::size_t&gt;  Representation in Luau This is a std::size_t, which is a 64-bit integer. Lua(u) cannot represent this type effectively. In order to counteract this, a string is returned when indexed by Lua(u). ","version":null,"tagName":"h3"},{"title":"How can I contribute to rSUNC","type":0,"sectionRef":"#","url":"/rSUNC/docs/HowCanIContribute","content":"How can I contribute to rSUNC Great! Thanks for trying to contribute to rSUNC. To contribute to rSUNC, you may fork our repository to begin. Then, head to either the docs or the impl folder, in which you will find a variety of files. To edit the documentation of rSUNC, which includes information on the spec and other details, edit the docs folder. If you want to add a new Library or edit one, head to the impl/Libraries/ folder, and edit or create the appropriate library, which you must tag according to the readme inside of impl/. If you need to create a new native type, say to represent a native structure in C/C++, then you must create a new definition in the impl/Types Once you have contributed, add yourself to the README's Contributors section, and make a pull request.","keywords":"","version":"Next"},{"title":"closures","type":0,"sectionRef":"#","url":"/rSUNC/api/closures","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#functions","content":" ","version":null,"tagName":"h2"},{"title":"getfunctionhash​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#getfunctionhash","content":"&lt;/&gt; closures.getfunctionhash( fn: (T...) → U...,-- The function to hash. hashType: &quot;SHA384&quot; | &quot;BLAKE2B&quot; | &quot;BLAKE3&quot;-- The hash type, defaults to SHA384. ) → string-- The hex representation of the selected hashType hash of the function. Provides a hash with a digest size of 48 bytes (384 bits) in hex format for the given function Implementation You must use the instructions and constants of the given function to obtain the hash. Compiler If your function is outputting different hashes every time its called, then you may have forgotten to account for Compiler settings. We recommend you read this post to know to resolve this issue and make your Luau compiler rSUNC compliannt. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures##","content":"Type\tDescriptionfunction must be a Luau closure.\tThe first parameter was a C function instead of a Luau function. Unsupported hash type.\tThe given hash type is not supported by the executor.  ","version":null,"tagName":"h3"},{"title":"hookfunction​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#hookfunction","content":"&lt;/&gt; closures.hookfunction( fn: (T...) → U...,-- Function to hook. hook: (T...) → U...-- The hook. ) → (T...) → U...-- The old/original function. Hooks the given function with the desired hook. This function supports hooking all kinds of closures, from Lua to C, C to Lua, etc. Implementations Some implementations of this function may bypass upvalue limits for you. If this is not the case, wrap hook in newcclosure/newlclosure before calling hookfunction. Restoring Hooked Functions You can restore functions hooked with hookfunction using restorefunction, in case restorefunction is not available you may unhook by calling hookfunction with the first function being the hooked function, and the second being the original one. Examples: Testing hookfunction and restorefunction: local function a() return &quot;baa&quot; end local function b() return &quot;caa&quot; end local aReturn = a() local bReturn = b() local hooked = closures.hookfunction(a, b) local hookedReturn = hooked() assert(hookedReturn == aReturn) assert(a() == b() and a() == bReturn) assert(hooked ~= a and b ~= a) closures.restorefunction(hooked, a) -- Restore a again. assert(a() == aReturn and a() ~= hookedReturn) -- If this script errors, your hookfunction may not be working properly. Example testing upvalue limits: local a = &quot;A&quot; local b = &quot;B&quot; local c = &quot;C&quot; local function a() -- Upvalue count: 3 a = &quot;B&quot; b = &quot;C&quot; c = &quot;D&quot; end local function b() -- Upvalue Count: 2 a = &quot;E&quot; b = &quot;F&quot; end a() -- Set variables local original = closures.hookfunction(a, b) -- If this call fails, consider implicitly wrapping `b` in a newlclosure! a() assert(a == &quot;E&quot; and b == &quot;F&quot; and c == &quot;D&quot;) -- If this errors, the upvalues are improperly set, and this could lead to a crash! assert() Example testing hooking pairs: local upref = false local dummyFunc = function(f) upref = f == &quot;Hello&quot; end local old; old = closures.hookfunction(coroutine.resume, dummyFunc) -- Hook C -&gt; L. This test also checks that hookfunction can bypass upvalue limits. coroutine.resume(&quot;Hello&quot;) if not upref then error(&quot;hookfunction&quot;, &quot;Failed to hook C -&gt; L Closures&quot;) end upref = false closures.hookfunction(coroutine.resume, old) pcall(coroutine.resume, &quot;Hello&quot;)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures##","content":"Type\tDescriptionToo many upvalues!\tThe function to hook has more upvalues than the function you want to hook it with. (This error may not show on some implementations.) This function cannot be hooked from Luau\tThe function has been marked as unhookable by `protectfunction` or by native executor code.  ","version":null,"tagName":"h3"},{"title":"restorefunction​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#restorefunction","content":"&lt;/&gt; closures.restorefunction( restoreWhat: (T...) → U...-- The function that should be restored. ) → () Restores any hooks done to restoreWhat, regardless of the hook type (i.e., C closure hook, Luau closure hook, ...) and of how many hooks were done to restoreWhat. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures##","content":"Type\tDescriptionFunction is not hooked\tThe function is not hooked, and thus cannot be restored. Use `ishooked` before calling this function!  ","version":null,"tagName":"h3"},{"title":"loadstring​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#loadstring","content":"&lt;/&gt; closures.loadstring( luauCode: string,-- The code to compile and load. chunkName: string?-- The name of the chunk to load. ) → ( ((T...) → U...) | nil,-- The loaded function, if loading succeeded. string?-- The error message, if loading failed. ) Compiles and loads the given luauCode. If chunkName is not provided, it must default to either: a pseudo-randomly generated string, or =loadstring. Loadstring must compile the code with the following compile configuration: - Optimization Level 1 - Debug Level 1 The function must also mark the environment as 'unsafe' to disable environment optimizations as per Luau specifications. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures##","content":"Type\tDescriptionN/A\tThis function does not explicitly error, however it returns an error message if the code fails to load in the second return.  ","version":null,"tagName":"h3"},{"title":"newcclosure​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#newcclosure","content":"&lt;/&gt; closures.newcclosure( fn: (T...) → U...,-- Function to wrap debugName: string?-- The name of the function, optional. ) → (T...) → U... Wraps the given closure into a upvalue-less C closure.  ","version":null,"tagName":"h3"},{"title":"newlclosure​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#newlclosure","content":"&lt;/&gt; closures.newlclosure( fn: (T...) → U...-- Function to wrap ) → (T...) → U... Wraps the given closure into a upvalue-less L closure. Obfuscators Obfuscators like Luraph™ use the function environment to wrap closures and bypass upvalue limits. Make sure that the environment of the pushed wrapper proxies the environment of the original function using __index. This should fix issues relating to Luraph™ not working with this function. WARNING This function, depending on the implementation, may rely on function environments to work or in a closure map-backed proxy function (like in newcclosure). Beware of this when using the function. Example Implementation (In Luau) local function newlclosure&lt;T..., U...&gt;(f: (T...) -&gt; U...): (T...) -&gt; U... local env = getfenv(f) -- Get environment (env of f gets deoptimized) local x = setmetatable({ __F = f, -- Store function on environment (prevents upreference) }, { __index = env, -- proxy original fenv for obfuscator support __newindex = env, -- proxy original fenv for obfuscator support }) local nf = function(...) return __F(...) -- proxy call end setfenv(nf, x) -- set func env (env of nf gets deoptimized) return nf end   ","version":null,"tagName":"h3"},{"title":"wrapclosure​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#wrapclosure","content":"&lt;/&gt; closures.wrapclosure( fn: (T...) → U...-- Function to wrap ) → (T...) → U...-- A copy of the function, without upvalues. Wraps the given closure into an upvalue-less version of itself. INFO This function is a proxy to the correct implementation of newcclosure/ newlclosure. Examples: local b = &quot;b&quot; local function a() -- Upvalue Count: 1 ('b') b = &quot;a&quot; end assert(#debug.getupvalues(a) == 1, &quot;debug.getupvalues failure&quot;) -- Validate the behaviour of debug.getupvalues. assert(#debug.getupvalues(closures.wrapclosure(a)) == 0, &quot;wrapped closure has upreferences/upvalues&quot;) assert(islclosure(a) == iscclosure(closures.wrapclosure(a)), &quot;closure type mismatch&quot;) -- If this script errors, your wrapclosure may not be working properly.   ","version":null,"tagName":"h3"},{"title":"isexecutorclosure​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#isexecutorclosure","content":"&lt;/&gt; closures.isexecutorclosure( fn: (T...) → U...-- The function to check. ) → boolean-- Whether the function is an executor closure. Checks if the given function is an executor closure. Implementation The function may use any method, as long as it returns true for executor Luau and C functions, as well as hooked functions, and false for any non-executor functions. This means that functions retrieved from loadstring or getscriptclosure will also return true.  ","version":null,"tagName":"h3"},{"title":"clonefunction​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#clonefunction","content":"&lt;/&gt; closures.clonefunction( fn: (T...) → U...-- The function to clone. ) → (T...) → U...-- A clone of the function. Clones the given function, providing a unique copy of it that is completely unrelated to fn. Obfuscator Support You must note that a cloned Luau function must have the SAME environment as the original function. If you do not provide an environment and an obfuscator depends on it for upvalues, you may face script errors. This has been documented behaviour on scripts obfuscated by obfuscators such as Luraph, where newlclosure and/or clonefunction do not properly set the environment of the cloned function, which causes script errors.  ","version":null,"tagName":"h3"},{"title":"isclosureprotected​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#isclosureprotected","content":"&lt;/&gt; closures.isclosureprotected( fn: (T...) → U...-- The function to check. ) → boolean-- If true, the function is protected against hooking. Returns if the given function is protected against hooks. Whitelists You can use this function if your executor abides by rSUNC to determine if the environment is proper for your whitelist.  ","version":null,"tagName":"h3"},{"title":"ishooked​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#ishooked","content":"&lt;/&gt; closures.ishooked( fn: (T...) → U...-- The function to check. ) → boolean-- Whether the function has been hooked. Returns if the given function has been hooked. Whitelists You can use this function if your executor abides by rSUNC to determine if the environment is proper for your whitelist.  ","version":null,"tagName":"h3"},{"title":"protectfunction​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#protectfunction","content":"&lt;/&gt; closures.protectfunction( fn: (T...) → U...-- The function to make unhookable and remove all hooks of. ) → () Makes a function unable to be hooked. This function automatically reverts ANY hooks placed on the function if there are any set.  ","version":null,"tagName":"h3"},{"title":"comparefunction​","type":1,"pageTitle":"closures","url":"/rSUNC/api/closures#comparefunction","content":"&lt;/&gt; closures.comparefunction( fn1: (T...) → U...,-- The first function to compare. fn2: (T...) → U...-- The second function to compare. ) → boolean-- Whether the two functions point to the same code. Returns true if the function points to the same code. The function should return false if the function type results in a mis-match (i.e., fn1 is a Luau closure and fn2 is a C closure). newcclosures/ newlclosure comparison For newcclosures and newlclosures, the result must be derived from the 'deepest' closure it wraps. For example, if fn1 is a newcclosure that wraps a newlclosure that wraps a luau function, and fn2 is a Luau function, you must search to the deepst call fn1 can do and check if it is fn2. The same should happen if fn2 is the nested one and fn1 is a luau function. This function does not check if the function code is the same, only if the two functions point to the same 'Prototype' or 'C function'. Examples print&quot;comparefunction test&quot; local x = function() end print(comparefunction(function() end, function() end)) -- false print(comparefunction(x, x)) -- true print(comparefunction(x, clonefunction(x))) -- true print(comparefunction(x, newcclosure(x))) -- true print(comparefunction(x, newlclosure(x))) -- true print(comparefunction(newcclosure(x), x)) -- true print(comparefunction(newlclosure(x), x)) -- true print(comparefunction(print, newcclosure(print))) -- true print(comparefunction(print, newlclosure(print))) -- true print(comparefunction(print, newcclosure(warn))) -- false print(comparefunction(print, newlclosure(warn))) -- false print(comparefunction(newcclosure(print), newcclosure(print))) -- true print(comparefunction( newcclosure( newlclosure( newcclosure( print ) ) ), newlclosure( newcclosure( newlclosure( print ) ) )) ) -- true print&quot;comparefunction test end&quot;  ","version":null,"tagName":"h3"},{"title":"SchedulerJobStepConnection","type":0,"sectionRef":"#","url":"/rSUNC/api/SchedulerJobStepConnection","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"SchedulerJobStepConnection","url":"/rSUNC/api/SchedulerJobStepConnection#properties","content":" ","version":null,"tagName":"h2"},{"title":"IsConnected​","type":1,"pageTitle":"SchedulerJobStepConnection","url":"/rSUNC/api/SchedulerJobStepConnection#IsConnected","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; SchedulerJobStepConnection.IsConnected: boolean If true, this connection is being actively fired, otherwise it was disconnected.  ","version":null,"tagName":"h3"},{"title":"IsEnabled​","type":1,"pageTitle":"SchedulerJobStepConnection","url":"/rSUNC/api/SchedulerJobStepConnection#IsEnabled","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; SchedulerJobStepConnection.IsEnabled: boolean If true, this connection can be fired, otherwise it was temporarily disabled with :Disable() ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"SchedulerJobStepConnection","url":"/rSUNC/api/SchedulerJobStepConnection#functions","content":" ","version":null,"tagName":"h2"},{"title":"Enable​","type":1,"pageTitle":"SchedulerJobStepConnection","url":"/rSUNC/api/SchedulerJobStepConnection#Enable","content":"&lt;/&gt; SchedulerJobStepConnection:Enable() → () Enables the connection to be fired, if disabled with :Disable()  ","version":null,"tagName":"h3"},{"title":"Disable​","type":1,"pageTitle":"SchedulerJobStepConnection","url":"/rSUNC/api/SchedulerJobStepConnection#Disable","content":"&lt;/&gt; SchedulerJobStepConnection:Disable() → () Prevents this connection from being temporarily fired, can be re-enabled with :Enable()  ","version":null,"tagName":"h3"},{"title":"Disconnect​","type":1,"pageTitle":"SchedulerJobStepConnection","url":"/rSUNC/api/SchedulerJobStepConnection#Disconnect","content":"&lt;/&gt; SchedulerJobStepConnection:Disconnect() → () Disconnects this connection which stops it from being fired. This will make this connection unusable in the future. ","version":null,"tagName":"h3"},{"title":"Luau Compiler Compliance","type":0,"sectionRef":"#","url":"/rSUNC/docs/CompilerCompliance","content":"Luau Compiler Compliance When compiling bytecode using Luau::compile, the bytecode emitted will contain the GETIMPORTS bytecode instruction. This is generally fine on tables that are immutable (meaning they do not change), however globals such as workspace, game and a few others such as script cannot suffer from this behaviour. Why is this an issue?​ If we inspect luau_load, we will see that when it is deserializing and loading the bytecode into memory, they do something tricky on the constants, they have a specific clase called LBC_CONSTANT_IMPORT. This is a Luau optimization that attempts to obtain everything a function may need that is known to not change, in order to improve performance. This is great! However, this indirectly inlines properties from globals such as game, workspace and others. This behaviour is bad. ROBLOX themselves know this is an issue, and have made internally a small list for the compiler to not optimize these on the CompilerOptions::mutableGlobals field of the compiler options, which is the following: const char *mutableGlobals[] = { &quot;Game&quot;, &quot;Workspace&quot;, &quot;game&quot;, &quot;plugin&quot;, &quot;script&quot;, &quot;shared&quot;, &quot;workspace&quot;, nullptr }; However, rSUNC has its own set of mutable globals which must also be defined on this array to prevent issues, which are the following _ENV, _GENV and _RENV. This also includes Luau optimizations for Vector types, Luau optimizes them properly on Roblox-compiled code as they have already resolved this issue, however we do not have this resolved! In order to allow the Vector3 optimizations to shine we must set the CompilerOptions::vectorLib, CompilerOptions::vectorCtor and CompilerOptions::vectorType to the appropriate values, being Vector3, new and Vector3. We also need to note that you must make use of CompilerOptions::optimizationLevel to be of 1 and the CompilerOptions::debugLevel to be of 1. In summary, we must make our compiler play nice with ROBLOX, as well as with our types. This concludes on a simple CompileLuau function. std::string CompileLuau(std::string_view szLuauCode) { const char *mutableGlobals[] = { &quot;Game&quot;, &quot;Workspace&quot;, &quot;game&quot;, &quot;plugin&quot;, &quot;script&quot;, &quot;shared&quot;, &quot;workspace&quot;, &quot;_ENV&quot;, &quot;_GENV&quot;, &quot;_RENV&quot;, // rSUNC globals. nullptr }; auto compileOpts = Luau::CompileOptions { }; compileOpts.optimizationLevel = 1; compileOpts.debugLevel = 1; compileOpts.vectorLib = &quot;Vector3&quot;; compileOpts.vectorCtor = &quot;new&quot;; compileOpts.vectorType = &quot;Vector3&quot;; compileOpts.mutableGlobals = mutableGlobals; return Luau::compile(szLuauCode.data(), compileOpts, {}, BYTECODE_ENCODER /* Studio requires no bytecode encoder! */); } This function contains all elements required to have your compiler be rSUNC compliant.","keywords":"","version":"Next"},{"title":"scheduler","type":0,"sectionRef":"#","url":"/rSUNC/api/scheduler","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"scheduler","url":"/rSUNC/api/scheduler#types","content":" ","version":null,"tagName":"h2"},{"title":"SchedulerJobName​","type":1,"pageTitle":"scheduler","url":"/rSUNC/api/scheduler#SchedulerJobName","content":"&lt;/&gt; type SchedulerJobName = &quot;RenderJob&quot; | &quot;WaitingHybridScriptsJob&quot; | &quot;ModelMeshJob&quot; | &quot;GcJob&quot; | &quot;HeartbeatTask&quot; | &quot;PhysicsJob&quot; | &quot;PathUpdateJob&quot; | &quot;NavigationJob&quot; | &quot;GenericDataModelJob&quot; | &quot;HttpRbxApiJob&quot;  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"scheduler","url":"/rSUNC/api/scheduler#functions","content":" ","version":null,"tagName":"h2"},{"title":"connectprestep​","type":1,"pageTitle":"scheduler","url":"/rSUNC/api/scheduler#connectprestep","content":"&lt;/&gt; scheduler.connectprestep( jobName: SchedulerJobName, callback: (T...) → U... ) → SchedulerJobStepConnection Connects a function to run before a Step of the specified job is ran. Callback Note The callback you provide CANNOT yield or block the thread, or you will block the roblox main thread. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"scheduler","url":"/rSUNC/api/scheduler##","content":"Type\tDescriptionUnknown Job\tThis job doesn't exist or is not supported.  ","version":null,"tagName":"h3"},{"title":"connectpoststep​","type":1,"pageTitle":"scheduler","url":"/rSUNC/api/scheduler#connectpoststep","content":"&lt;/&gt; scheduler.connectpoststep( jobName: SchedulerJobName, callback: (T...) → U... ) → SchedulerJobStepConnection Connects a function to run after a Step of the specified job is ran. Callback Note The callback you provide CANNOT yield or block the thread, or you will block the roblox main thread. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"scheduler","url":"/rSUNC/api/scheduler##","content":"Type\tDescriptionUnknown Job\tThis job doesn't exist or is not supported. ","version":null,"tagName":"h3"},{"title":"global","type":0,"sectionRef":"#","url":"/rSUNC/api/global","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"global","url":"/rSUNC/api/global#properties","content":" ","version":null,"tagName":"h2"},{"title":"_RENV​","type":1,"pageTitle":"global","url":"/rSUNC/api/global#_RENV","content":"Global &lt;/&gt; global._RENV: {[any]: any} The global roblox environment, as a table.  ","version":null,"tagName":"h3"},{"title":"_GENV​","type":1,"pageTitle":"global","url":"/rSUNC/api/global#_GENV","content":"Global &lt;/&gt; global._GENV: {[any]: any} The global executor environment, as a table.  ","version":null,"tagName":"h3"},{"title":"_ENV​","type":1,"pageTitle":"global","url":"/rSUNC/api/global#_ENV","content":"Global &lt;/&gt; global._ENV: {[any]: any} The current thread's environment, as a table. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"global","url":"/rSUNC/api/global#functions","content":" ","version":null,"tagName":"h2"},{"title":"httpget​","type":1,"pageTitle":"global","url":"/rSUNC/api/global#httpget","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields Global &lt;/&gt; global.httpget( url: string-- The URL to send the request to. ) → string-- The body of the response. Fetches the Body of an HTTP server using a GET HTTP request. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"global","url":"/rSUNC/api/global##","content":"Type\tDescriptionInvalid protocol (expected 'http://' or 'https://')\tThe provided URL is not on the form of an HTTP request.  ","version":null,"tagName":"h3"},{"title":"messagebox​","type":1,"pageTitle":"global","url":"/rSUNC/api/global#messagebox","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields Global &lt;/&gt; global.messagebox( text: string,-- The text to display in the message box. caption: string,-- The caption to display in the message box. flags: number-- The flags to apply to the message box. ) → number-- The result of the message box. Creates a Win32 MessageBox with the provided text, caption, and flags. Yields until the message box is closed. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"global","url":"/rSUNC/api/global##","content":"Type\tDescriptionWin32 error '%s'\tAn error occured while trying to display the messagebox. The Win32 error will be in-place of the '%s'. ","version":null,"tagName":"h3"},{"title":"Index","type":0,"sectionRef":"#","url":"/rSUNC/docs/intro","content":"Index Index for rSUNC docs. !! Important For Executor Developers !! Luau Compiler Complance Why should I use rSUNC? rSUNC and UNC How to contirbute?","keywords":"","version":"Next"},{"title":"instances","type":0,"sectionRef":"#","url":"/rSUNC/api/instances","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"instances","url":"/rSUNC/api/instances#functions","content":" ","version":null,"tagName":"h2"},{"title":"cloneref​","type":1,"pageTitle":"instances","url":"/rSUNC/api/instances#cloneref","content":"&lt;/&gt; instances.cloneref( object: Instance -- The instance to clone. ) → Instance -- A brand new reference to the given instance. Clones a reference of the given instance. Usage By cloning references to instances, you can bypass weak table-style attacks, which is a way of detecting references to objects which should not have references.  ","version":null,"tagName":"h3"},{"title":"compareinstances​","type":1,"pageTitle":"instances","url":"/rSUNC/api/instances#compareinstances","content":"&lt;/&gt; instances.compareinstances( object1: Instance ,-- The first instance. object2: Instance -- The second instance. ) → boolean-- If true, both references point to the same instance, else false. Compares the underlying instances of two object references. Usage instances.cloneref allows you to clone a reference to an object, this breaks the normal way Roblox performs equality checks. This function allows you to compare the actual thing the two references point to, allowing you to know if they reference the same instance!  ","version":null,"tagName":"h3"},{"title":"invalidatereference​","type":1,"pageTitle":"instances","url":"/rSUNC/api/instances#invalidatereference","content":"&lt;/&gt; instances.invalidatereference( object: Instance -- The instance to invalidate. ) → () Invalidates the reference of the given instance. Usage Invalidating the reference to an instance allows you to make subsequent calls to certain functions return a different pointer instead of the one you have. This also makes the reference you hold unique to you up to that point. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"instances","url":"/rSUNC/api/instances##","content":"Type\tDescriptionThe reference cannot be invalidated (not in cache)\tThe reference you provided cannot be invalidated, this is due to it not being on the instance cache.  ","version":null,"tagName":"h3"},{"title":"isreferencevalid​","type":1,"pageTitle":"instances","url":"/rSUNC/api/instances#isreferencevalid","content":"&lt;/&gt; instances.isreferencevalid( object: Instance -- The instance to check. ) → boolean-- If true, the reference to the instance is still valid. Checks if the reference to the given instance is still valid. Usage This function is used to check if an instance is still valid after the reference is invalidated using instances.invalidatereference.  ","version":null,"tagName":"h3"},{"title":"replacereference​","type":1,"pageTitle":"instances","url":"/rSUNC/api/instances#replacereference","content":"&lt;/&gt; instances.replacereference( object1: Instance ,-- The instance to replace. object2: Instance -- The instance to replace it with. ) → () Makes all references that are object1 point to what object2 is referencing instead. Usage You can use this function to replace references to an instance all throughout the game. i.e.: replacing a Value instance and affecting all already obtained references to it. Remarks Some instances, such as the DataModel (aka game), are not affected by this function. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"instances","url":"/rSUNC/api/instances##","content":"Type\tDescriptionThe reference cannot be modified (not in cache)\tThe reference you provided cannot be modified, this is due to it not being on the instance cache.  ","version":null,"tagName":"h3"},{"title":"getplaceversion​","type":1,"pageTitle":"instances","url":"/rSUNC/api/instances#getplaceversion","content":"&lt;/&gt; instances.getplaceversion() → number-- The version of the place. Gets the version of the ROBLOX place you are in. Usage This function can be used to guarantee features work only on a version deemed 'safe' of the game. Useful for premium scripts.  ","version":null,"tagName":"h3"},{"title":"getcallbackvalue​","type":1,"pageTitle":"instances","url":"/rSUNC/api/instances#getcallbackvalue","content":"&lt;/&gt; instances.getcallbackvalue( instance: Instance ,-- The instance to get the callback value from. prop: string-- The that is the callback. ) → (T...) → U...-- The callback that the instance contains at the given property. Gets the callback value of the given instance and property. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"instances","url":"/rSUNC/api/instances##","content":"Type\tDescriptionproperty with name '%s' does not exist.\tThe given property (named %s) does not exist on the given instance.  ","version":null,"tagName":"h3"},{"title":"gethiddenproperty​","type":1,"pageTitle":"instances","url":"/rSUNC/api/instances#gethiddenproperty","content":"&lt;/&gt; instances.gethiddenproperty( instance: Instance ,-- The instance to get the property from. prop: string-- The property to get. ) → ( T,-- The value of the property. boolean-- True if the property is hidden. ) Gets the property of the given instance. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"instances","url":"/rSUNC/api/instances##","content":"Type\tDescriptionproperty with name '%s' does not exist.\tThe given property (named %s) does not exist on the given instance. ","version":null,"tagName":"h3"},{"title":"http","type":0,"sectionRef":"#","url":"/rSUNC/api/http","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"http","url":"/rSUNC/api/http#functions","content":" ","version":null,"tagName":"h2"},{"title":"request​","type":1,"pageTitle":"http","url":"/rSUNC/api/http#request","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; http.request( options: rSUNCHttpRequest-- The parameters for the http request. ) → rSUNCHttpResponse-- A response to the rSUNCHttpRequest. Performs an HTTP request with the given options, providing the given response Headers By default, this function attaches the following headers: {ExecutorName}-User-Identifier\t-- A string unique to each user, and does not change if the script executor is used across computers, useful to check if a user is the same, regardless of computer. {ExecutorName}-Fingerprint -- The hardware identifier of the user, useful to check if the user is using the same computer. User-Agent -- The name and version of the executor.  ","version":null,"tagName":"h3"},{"title":"runtime","type":0,"sectionRef":"#","url":"/rSUNC/api/runtime","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#functions","content":" ","version":null,"tagName":"h2"},{"title":"disablenative​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#disablenative","content":"&lt;/&gt; runtime.disablenative( fn: (T...) → U...-- The function to disable native code execution for. ) → () Disables the execution of native generated code for the provided function. Hooking functions You may need to call this function in the future before hooking functions! ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime##","content":"Type\tDescriptionVM is not supported\tThe VM does not support native code. the function is present on the callstack\tThe function is present on the current threads callstack. You cannot disable native code for a function that is currently being executed.  ","version":null,"tagName":"h3"},{"title":"enablenative​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#enablenative","content":"&lt;/&gt; runtime.enablenative( fn: (T...) → U...-- The function to enable native code execution for. ) → () Enables the execution of native generated code, if the Lua(u) VM is prepared for it. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime##","content":"Type\tDescriptionVM is not supported\tThe VM does not support native code.  ","version":null,"tagName":"h3"},{"title":"isnativecode​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#isnativecode","content":"&lt;/&gt; runtime.isnativecode( fn: (T...) → U...-- The function to check. ) → boolean-- Whether the function is implemented in native code or running with a native code implementation. Checks if the current function is implemented in the form of native code (implemented in C or runs with generated native code).  ","version":null,"tagName":"h3"},{"title":"can_vm_run_native_code​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#can_vm_run_native_code","content":"&lt;/&gt; runtime.can_vm_run_native_code() → boolean-- Whether the VM can run native code. Checks if the current Lua(u) VM can run native code.  ","version":null,"tagName":"h3"},{"title":"getstringatom​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#getstringatom","content":"&lt;/&gt; runtime.getstringatom( str: string-- The string to get the atom of. ) → number-- The atom of str, as a signed 16 bit integer (short/I16/std::int16_t). Obtains the 'atom' of the given string str.  ","version":null,"tagName":"h3"},{"title":"getstringhash​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#getstringhash","content":"&lt;/&gt; runtime.getstringhash( str: string-- The string to get the hash of. ) → number-- The hash of str, as an unsigned integer. Obtains the hash of the given string str that was assigned to it by Lua(u).  ","version":null,"tagName":"h3"},{"title":"enablepointerencoding​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#enablepointerencoding","content":"&lt;/&gt; runtime.enablepointerencoding() → () Enables pointer encoding for the Lua(u) VM. Implementation This function should be implemented as a way to restore the pointer encryption key to the original value, using the key that RBX::ScriptContext contains. While any value is acceptable, it is recommended to use the value from RBX::ScriptContext in order to avoid issues.  ","version":null,"tagName":"h3"},{"title":"disablepointerencoding​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#disablepointerencoding","content":"&lt;/&gt; runtime.disablepointerencoding() → () Disables pointer encoding for the Lua(u) VM. Executor Development This can help locate objects in memory to find out about their true structure in memory.  ","version":null,"tagName":"h3"},{"title":"isinstance​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#isinstance","content":"&lt;/&gt; runtime.isinstance( obj: userdata-- The object to check. ) → boolean-- Whether the object is a userdata of type Instance. Returns whether the given object is a userdata of type Instance. Implementation This function should NEVER be implemented as a __type check. You must figure out a way to do it yourself.  ","version":null,"tagName":"h3"},{"title":"setluaufflag​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#setluaufflag","content":"&lt;/&gt; runtime.setluaufflag( flagName: string,-- The name of the flag to set. flagValue: boolean-- The value to set the flag to. ) → () Sets a fast flag in the Lua(u) VM for specific behaviour. Implementation This functions should affect the Roblox VM as well if you are using a RVM/CLVM execution method.  ","version":null,"tagName":"h3"},{"title":"disableerrorlogging​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#disableerrorlogging","content":"&lt;/&gt; runtime.disableerrorlogging() → () Disables the error logging Roblox does on the VM. This is NOT the same as disabling error logging in the VM itself, it simply disables the ScriptContext.Error signal. Implementation This function can be implemented using hooksignal or getconnections, but it must continue to work even if new connections are added to the event.  ","version":null,"tagName":"h3"},{"title":"enableerrorlogging​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#enableerrorlogging","content":"&lt;/&gt; runtime.enableerrorlogging() → () Enables the error logging Roblox does on the VM. This is NOT the same as disabling error logging in the VM itself, it simply enables the ScriptContext.Error signal again after being disabled.  ","version":null,"tagName":"h3"},{"title":"getrbxbuildhash​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#getrbxbuildhash","content":"Optional &lt;/&gt; runtime.getrbxbuildhash() → string-- The ROBLOX build hash. Returns the Version hash of the current, running ROBLOX version. The version hash is the hash that follows the 'version' string in version-....  ","version":null,"tagName":"h3"},{"title":"gethwid​","type":1,"pageTitle":"runtime","url":"/rSUNC/api/runtime#gethwid","content":"&lt;/&gt; runtime.gethwid() → string-- The hash of your tool's calculated HWID, as a hex string. Returns the HWID for the running computer. HWID Hashing After performing your own tool's HWID calculations, you are expected to provide a hex-formatted hash that cannot be reconstructed back to the original HWID. ","version":null,"tagName":"h3"}],"options":{"id":"default"}}