"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2260],{10520:e=>{e.exports=JSON.parse('{"functions":[{"name":"cloneref","desc":"Clones a reference of the given instance.\\n\\n\\n:::tip Usage\\nBy cloning references to instances, you can bypass weak table-style attacks, which is a way of detecting references to objects which should not have references.\\n:::","params":[{"name":"object","desc":"The instance to clone.","lua_type":"Instance"}],"returns":[{"desc":"A brand new reference to the given instance.","lua_type":"Instance"}],"function_type":"static","source":{"line":19,"path":"impl/Libraries/instances.luau"}},{"name":"compareinstances","desc":"Compares the underlying instances of two object references.\\n\\n\\n:::tip Usage\\n`instances.cloneref` allows you to clone a reference to an object, this breaks the normal way Roblox performs equality checks.\\n\\nThis function allows you to compare the actual thing the two references point to, allowing you to know if they reference the same instance!\\n:::","params":[{"name":"object1","desc":"The first instance.","lua_type":"Instance"},{"name":"object2","desc":"The second instance.","lua_type":"Instance"}],"returns":[{"desc":"If true, both references point to the same instance, else false.","lua_type":"boolean"}],"function_type":"static","source":{"line":37,"path":"impl/Libraries/instances.luau"}},{"name":"invalidatereference","desc":"Invalidates the reference of the given instance.\\n\\n\\n:::tip Usage\\nInvalidating the reference to an instance allows you to make subsequent calls to certain functions return a different pointer instead of the one you have. This also makes the reference you hold unique to you up to that point.\\n:::","params":[{"name":"object","desc":"The instance to invalidate.","lua_type":"Instance"}],"returns":[],"function_type":"static","errors":[{"lua_type":"The reference cannot be invalidated (not in cache)","desc":"The reference you provided cannot be invalidated, this is due to it not being on the instance cache."}],"source":{"line":52,"path":"impl/Libraries/instances.luau"}},{"name":"isreferencevalid","desc":"Checks if the reference to the given instance is still valid.\\n\\n\\n:::tip Usage\\nThis function is used to check if an instance is still valid after the reference is invalidated using `instances.invalidatereference`.\\n:::","params":[{"name":"object","desc":"The instance to check.","lua_type":"Instance"}],"returns":[{"desc":"If true, the reference to the instance is still valid.","lua_type":"boolean"}],"function_type":"static","source":{"line":65,"path":"impl/Libraries/instances.luau"}},{"name":"replacereference","desc":"Makes all references that are `object1` point to what `object2` is referencing instead.\\n\\n\\n:::tip Usage\\nYou can use this function to replace references to an instance all throughout the game. i.e.: replacing a Value instance and affecting all already obtained references to it.\\n:::\\n\\n:::note Remarks\\nSome instances, such as the DataModel (aka `game`), are not affected by this function.\\n:::","params":[{"name":"object1","desc":"The instance to replace.","lua_type":"Instance"},{"name":"object2","desc":"The instance to replace it with.","lua_type":"Instance"}],"returns":[],"function_type":"static","errors":[{"lua_type":"The reference cannot be modified (not in cache)","desc":"The reference you provided cannot be modified, this is due to it not being on the instance cache."}],"source":{"line":85,"path":"impl/Libraries/instances.luau"}},{"name":"getplaceversion","desc":"Gets the version of the ROBLOX place you are in.\\n\\n\\n:::tip Usage\\nThis function can be used to guarantee features work only on a version deemed \'safe\' of the game. Useful for premium scripts.\\n:::","params":[],"returns":[{"desc":"The version of the place.","lua_type":"number"}],"function_type":"static","source":{"line":97,"path":"impl/Libraries/instances.luau"}},{"name":"getcallbackvalue","desc":"Gets the callback value of the given instance and property.","params":[{"name":"instance","desc":"The instance to get the callback value from.","lua_type":"Instance"},{"name":"prop","desc":"The name of the callback property.","lua_type":"string"}],"returns":[{"desc":"The callback that the instance contains at the given property.","lua_type":"(T...) -> U..."}],"function_type":"static","errors":[{"lua_type":"property with name \'%s\' does not exist.","desc":"The given property (named %s) does not exist on the given instance."}],"source":{"line":110,"path":"impl/Libraries/instances.luau"}},{"name":"gethiddenproperty","desc":"Gets the property of the given instance.\\n\\n\\n:::warning Remarks\\nYou must support pushing unserializable properties such as \'`SharedString`\' and \'`SystemAddress`\'.\\n:::\\n\\n:::tip Implementation\\nYou are supposed to obtain the property using the `RBX::Instance::getProperty`/ `RBX::Instance::setProperty` methods. You must not set the property public or scriptable. \\n:::","params":[{"name":"instance","desc":"The instance to get the property from.","lua_type":"T & Instance"},{"name":"prop","desc":"The property to get.","lua_type":"string"}],"returns":[{"desc":"The value of the property.","lua_type":"U"},{"desc":"True if the property was hidden, false if it was not.","lua_type":"boolean"}],"function_type":"static","errors":[{"lua_type":"property with name \'%s\' does not exist.","desc":"The given property (named %s) does not exist on the given instance."}],"source":{"line":132,"path":"impl/Libraries/instances.luau"}},{"name":"getsenv","desc":"Gets the environment of a running script.\\n\\n\\n:::tip Implementation\\nThis function may perform GC scans to find script threads and obtain their environment.\\n:::\\n\\n:::danger Actors\\nIf the script is running in a different `mainthread` you must throw the \'script is running in a different Luau VM\' error in order to prevent possible vulnerabilities and other issues associated with actors.\\n:::","params":[{"name":"script","desc":"The script to obtain the environment of.","lua_type":"LuaSourceContainer"}],"returns":[{"desc":"The environment of the script, nil if the script is not running.","lua_type":"T | nil"}],"function_type":"static","errors":[{"lua_type":"script is running in a different Luau VM","desc":"The script you tried to get the environment does not share the same mainthread state (Running under an actor/ in a different Luau VM)."}],"source":{"line":151,"path":"impl/Libraries/instances.luau"}},{"name":"getscriptclosure","desc":"Gets a non-runnable closure which holds debug info (constants, upreferences, debugname, etc) of the script\'s main thread.\\n\\n:::danger Implementation \\nThis function may not perform a GC scan in an effort to find the Script object.\\n:::","params":[{"name":"instance","desc":"The script to get the closure of.","lua_type":"LuaSourceContainer"}],"returns":[{"desc":"The \'main\' closure of the script, `nil` if the script has no bytecode.","lua_type":"((T...) -> (U...)) | nil"}],"function_type":"static","errors":[{"lua_type":"Cannot get closure of a server script","desc":"The script provided is a server script, and its source isn\'t available."}],"source":{"line":165,"path":"impl/Libraries/instances.luau"}},{"name":"exchangeinstancepointer","desc":"Exchanges the underlying pointer between two instances.\\n\\n\\n:::tip Usage\\nThis can be used in place of `instances.replacereference` if the user already holds a reference to the object you want replaced. \\n\\nThis function, unlike `instances.replacereference` will overwrite the underlying pointer to the instance in the provided reference. This makes it so all instances of this reference are affected, regardless of whether they\'re just newly obtained from the Instance cache.\\n:::\\n\\n:::danger Implementation\\nThe instances MUST be strictly checked to be such.\\n:::","params":[{"name":"object1","desc":"The first instance.","lua_type":"Instance"},{"name":"object2","desc":"The second instance.","lua_type":"Instance"}],"returns":[],"function_type":"static","source":{"line":186,"path":"impl/Libraries/instances.luau"}},{"name":"fireclickdetector","desc":"Fires a click detector event, which replicates to the server.\\n\\n\\n:::danger Implementations\\nYou should not implement this function in luau.\\n:::","params":[{"name":"detector","desc":"The click detector to fire the event on.","lua_type":"ClickDetector"},{"name":"distance","desc":"The distance to fire the event at, if nil, defaults to 0.","lua_type":"number?"},{"name":"eventName","desc":"The event to fire, if nil, defaults to \\"MouseClick\\"","lua_type":"\\"MouseClick\\" | \\"RightMouseClick\\" | \\"MouseHoverEnter\\" | \\"MouseHoverLeave\\" | nil"}],"returns":[],"function_type":"static","source":{"line":200,"path":"impl/Libraries/instances.luau"}},{"name":"firetouchinterest","desc":"Fires a physics interaction between BasePart objects, which replicates to the server.\\n\\n\\n:::danger Implementations\\nYou should not implement this function in luau.\\n:::","params":[{"name":"part1","desc":"The first part.","lua_type":"BasePart"},{"name":"part2","desc":"The second part.","lua_type":"BasePart"},{"name":"touchType","desc":"The event to fire.","lua_type":"TouchType"}],"returns":[],"function_type":"static","errors":[{"lua_type":"no world found","desc":"No RBX::World was found for either Part1 or Part2."},{"lua_type":"overlap in a different world","desc":"Part1 and Part2 live in different RBX::World\'s and they cannot interact with each other."}],"source":{"line":233,"path":"impl/Libraries/instances.luau"}},{"name":"fireproximityprompt","desc":"Fires a proximity prompt\'s Triggered event, which replicates to the server.\\n\\n\\n:::danger Implementations\\nYou should not implement this function in luau.\\n:::","params":[{"name":"prompt","desc":"The prompt to fire the event on.","lua_type":"ProximityPrompt"}],"returns":[],"function_type":"static","source":{"line":247,"path":"impl/Libraries/instances.luau"}},{"name":"gethui","desc":"Returns the folder used by the executor to place User Interfaces.\\n\\n\\n:::danger Weak-Table attacks\\nThis function may be vulnerarble to weak-table style attacks if not properly implemented.\\n\\nMake a folder, parent it to CoreGui, and then use `instances.invalidatereference` on it, then return the created folder, this should protect you from this kind of attack!\\n:::\\n\\n:::danger ContentProvider attacks\\nGame developers can use `ContentProvider:PreloadAsync` to detect assets loaded in CoreGui when they should not be loaded, due to this they can check if any UI has been loaded that is not the \\ndefault ROBLOX Core Gui. You must protect yourself from this kind of attack by caching the return of CoreGui for the function, and returning the cached value after gethui is called. This should maintain the integrity of the system while hiding the new assets that are loaded on CoreGui. *This change may also be needed on the `game` instance*.\\n:::","params":[],"returns":[{"desc":"The folder which is hidden from the game context.","lua_type":"Folder"}],"function_type":"static","source":{"line":266,"path":"impl/Libraries/instances.luau"}},{"name":"getinstances","desc":"Returns a list with all instances that are currently referenced by the game.\\n\\n\\n:::warning Actors\\nIf an instance is referenced inside an actor, this list of instances should not contain it!\\n:::","params":[],"returns":[{"desc":"All instances that are currently referenced by the game.","lua_type":"{ Instance }"}],"function_type":"static","source":{"line":280,"path":"impl/Libraries/instances.luau"}},{"name":"getnilinstances","desc":"Returns a list with all instances that are currently referenced by the game and are not parented anything.\\n\\n\\n:::warning Actors\\nIf an instance is referenced inside an actor, this list of instances should not contain it!\\n:::","params":[],"returns":[{"desc":"All instances that are currently referenced by the game, but with no parent.","lua_type":"{ Instance }"}],"function_type":"static","source":{"line":294,"path":"impl/Libraries/instances.luau"}},{"name":"getinstancelist","desc":"Returns a dictionary with all instances that are currently referenced by the game as their value, and a lightuserdata as their key.\\n\\nThis dictionary is also known as the instance cache.\\n\\n\\n:::warning Actors\\nIf an instance is referenced inside an actor, this list of instances should not contain it!\\n:::","params":[],"returns":[{"desc":"The internal list ROBLOX uses for holding references to instances in Luau.","lua_type":"{ [userdata]: Instance }"}],"function_type":"static","source":{"line":310,"path":"impl/Libraries/instances.luau"}},{"name":"getconnections","desc":"Retrieves a list of connection objects associated with a given signal.\\n\\n\\n:::tip Usage\\nThis function allows you to inspect and manage individual connections to a signal. You can check properties like the connected function, its thread, whether it\'s enabled, or even manually fire, defer, enable, disable, or disconnect specific connections.\\n:::\\n\\n:::warning Remarks\\n- Calling `Disconnect` on an `Connection` object invalidates it. Subsequent attempts to use the object will result in an error.\\n- `Fire` and `Defer` methods will not work for connections where `ForeignState` is true (i.e., C functions or connections from different Luau VMs).\\n- The order of connections in the returned table might not be predictable.\\n:::","params":[{"name":"signal","desc":"The signal instance (e.g., `game.Players.PlayerAdded`) to get connections from.","lua_type":"RBXScriptSignal"}],"returns":[{"desc":"An array-like table containing `Connection` objects for each active connection to the signal.","lua_type":"{ Connection }"}],"function_type":"static","errors":[{"lua_type":"Expected RBXScriptSignal","desc":"The provided argument was not an `RBXScriptSignal`."}],"source":{"line":332,"path":"impl/Libraries/instances.luau"}}],"properties":[],"types":[{"name":"TouchType","desc":"Describes a TouchType for the firetouchinterest function. \\n\\n**`1`** stands for **`Touch`**, while **`0`** stands for **`TouchEnded`**.","lua_type":"1 | 0","tags":["Type"],"source":{"line":217,"path":"impl/Libraries/instances.luau"}}],"name":"instances","desc":"Provides functions to manipulate instances.","tags":["Library"],"source":{"line":6,"path":"impl/Libraries/instances.luau"}}')}}]);